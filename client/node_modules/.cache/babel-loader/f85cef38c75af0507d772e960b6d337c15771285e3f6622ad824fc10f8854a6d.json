{"ast":null,"code":"\"use strict\";\n\nvar _require = require(\"./doc-utils.js\"),\n  startsWith = _require.startsWith,\n  endsWith = _require.endsWith,\n  isStarting = _require.isStarting,\n  isEnding = _require.isEnding,\n  isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = require(\"./filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n  var lastNonEmpty = \"\";\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var p = parts[i];\n    if (isWhiteSpace(p)) {\n      continue;\n    }\n    if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n      if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\")) {\n        p = \"<w:p/>\".concat(p);\n      }\n    }\n    lastNonEmpty = p;\n    parts[i] = p;\n  }\n  return parts;\n}\n\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n  var contains = options.fileTypeConfig.tagShouldContain || [];\n  /* Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   */\n  var collecting = \"\";\n  var currentlyCollecting = -1;\n  if (filetypes.docx.indexOf(options.contentType) !== -1) {\n    parts = addEmptyParagraphAfterTable(parts);\n  }\n  var startIndex = -1;\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var part = parts[i];\n    for (var j = 0, len2 = contains.length; j < len2; j++) {\n      var _contains$j = contains[j],\n        tag = _contains$j.tag,\n        shouldContain = _contains$j.shouldContain,\n        value = _contains$j.value,\n        drop = _contains$j.drop;\n      if (currentlyCollecting === j) {\n        if (isEnding(part, tag)) {\n          currentlyCollecting = -1;\n          if (drop) {\n            for (var k = startIndex; k <= i; k++) {\n              parts[k] = \"\";\n            }\n          } else {\n            for (var _k = startIndex; _k < i; _k++) {\n              parts[_k] = \"\";\n            }\n            parts[i] = collecting + value + part;\n          }\n          break;\n        }\n        collecting += part;\n        for (var _k2 = 0, len3 = shouldContain.length; _k2 < len3; _k2++) {\n          var sc = shouldContain[_k2];\n          if (isStarting(part, sc)) {\n            currentlyCollecting = -1;\n            // parts[i] = collecting;\n            break;\n          }\n        }\n        if (currentlyCollecting > -1) {\n          // parts[i] = \"\";\n        }\n        break;\n      }\n      if (currentlyCollecting === -1 && isStarting(part, tag) &&\n      // to verify that the part doesn't have multiple tags, such as <w:tc><w:p>\n      part.substr(1).indexOf(\"<\") === -1) {\n        // self-closing tag such as <w:t/>\n        if (part[part.length - 2] === \"/\") {\n          parts[i] = \"\";\n          break;\n        } else {\n          startIndex = i;\n          currentlyCollecting = j;\n          collecting = part;\n          // parts[i] = \"\";\n          break;\n        }\n      }\n    }\n  }\n  return parts;\n}\nmodule.exports = joinUncorrupt;","map":{"version":3,"names":["_require","require","startsWith","endsWith","isStarting","isEnding","isWhiteSpace","filetypes","addEmptyParagraphAfterTable","parts","lastNonEmpty","i","len","length","p","concat","joinUncorrupt","options","contains","fileTypeConfig","tagShouldContain","collecting","currentlyCollecting","docx","indexOf","contentType","startIndex","part","j","len2","_contains$j","tag","shouldContain","value","drop","k","_k","_k2","len3","sc","substr","module","exports"],"sources":["/Users/hardpro/Desktop/Vue JS/aics-attend/client/node_modules/docxtemplater/js/join-uncorrupt.js"],"sourcesContent":["\"use strict\";\n\nvar _require = require(\"./doc-utils.js\"),\n  startsWith = _require.startsWith,\n  endsWith = _require.endsWith,\n  isStarting = _require.isStarting,\n  isEnding = _require.isEnding,\n  isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = require(\"./filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n  var lastNonEmpty = \"\";\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var p = parts[i];\n    if (isWhiteSpace(p)) {\n      continue;\n    }\n    if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n      if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\")) {\n        p = \"<w:p/>\".concat(p);\n      }\n    }\n    lastNonEmpty = p;\n    parts[i] = p;\n  }\n  return parts;\n}\n\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n  var contains = options.fileTypeConfig.tagShouldContain || [];\n  /* Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   */\n  var collecting = \"\";\n  var currentlyCollecting = -1;\n  if (filetypes.docx.indexOf(options.contentType) !== -1) {\n    parts = addEmptyParagraphAfterTable(parts);\n  }\n  var startIndex = -1;\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var part = parts[i];\n    for (var j = 0, len2 = contains.length; j < len2; j++) {\n      var _contains$j = contains[j],\n        tag = _contains$j.tag,\n        shouldContain = _contains$j.shouldContain,\n        value = _contains$j.value,\n        drop = _contains$j.drop;\n      if (currentlyCollecting === j) {\n        if (isEnding(part, tag)) {\n          currentlyCollecting = -1;\n          if (drop) {\n            for (var k = startIndex; k <= i; k++) {\n              parts[k] = \"\";\n            }\n          } else {\n            for (var _k = startIndex; _k < i; _k++) {\n              parts[_k] = \"\";\n            }\n            parts[i] = collecting + value + part;\n          }\n          break;\n        }\n        collecting += part;\n        for (var _k2 = 0, len3 = shouldContain.length; _k2 < len3; _k2++) {\n          var sc = shouldContain[_k2];\n          if (isStarting(part, sc)) {\n            currentlyCollecting = -1;\n            // parts[i] = collecting;\n            break;\n          }\n        }\n        if (currentlyCollecting > -1) {\n          // parts[i] = \"\";\n        }\n        break;\n      }\n      if (currentlyCollecting === -1 && isStarting(part, tag) &&\n      // to verify that the part doesn't have multiple tags, such as <w:tc><w:p>\n      part.substr(1).indexOf(\"<\") === -1) {\n        // self-closing tag such as <w:t/>\n        if (part[part.length - 2] === \"/\") {\n          parts[i] = \"\";\n          break;\n        } else {\n          startIndex = i;\n          currentlyCollecting = j;\n          collecting = part;\n          // parts[i] = \"\";\n          break;\n        }\n      }\n    }\n  }\n  return parts;\n}\nmodule.exports = joinUncorrupt;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}